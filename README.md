# PATTERNS 

# singleton-code

클래스 이름 뒤에 01, 02, 03 이순서로 확인한다.
싱글톤을 사용하는 방법들중에 SingletonInstanceHolder04 클래스의 방법과 Enum을 사용하는 방법을 가장 많이 사용한다. 이펙티브 자바를 쓴 조슈아 블로크가 추천한 방법이기도 하다.

## 정적 멤버
정적(statiac) 멤버나 블록은 런타임이 아니라 최초에 JVM이 클래스 로딩 때 모든 클래스들을 로드할 때 미리 인스턴스를 생성하는데 이를 이용한 방법입니다.
클래스 로딩과 동시에 싱글톤 인스턴스를 만듭니다. 그렇기 때문에 모듈들이 싱글톤 인스턴스를 요청할 때 그냥 만들어진 인스턴스를 반환하면 되는 것이죠.

이는 불필요한 자원낭비라는 문제점이 있습니다. 싱글톤 인스턴스가 필요없는 경우도 무조건 싱글톤 클래스를 호출해 인스턴스를 만들어야 하기 때문입니다. 이문제는 정적 블록 문제점이기도 합니다.

## volatile
SingletonDoubleLock에 instance라는 변수에 volatile 키워드를 건 것을 볼 수 있는데요.
여기서 instance라는 변수에 volatile 키워드를 건 것을 볼 수 있는데요.
왜 그랬을까요?
메모리 구조는 다음과 같습니다. 메인 메모리 위에 CPU 캐시메모리라고 불리는 L3, L3, L1 캐시가 있습니다. (L4도 드물긴 하지만 L4까지 CPU 캐시 메모리라고 부릅니다.)<br>
<img width="348" alt="image" src="https://github.com/SeongjinOliver/singleton-code/assets/55625864/5e22838b-6445-4e3f-ab93-13b0d97b490c"><br>
JAVA에서는 스레드 2개가 열리면 변수를 메인 메모리(RAM)으로부터 가져오는 것이 아니라 캐시메모리에서 각각의 캐시메모리를 기반으로 가져오게 됩니다.
<img width="476" alt="image" src="https://github.com/SeongjinOliver/singleton-code/assets/55625864/826384fb-4b52-4ecb-bb71-4c93956c0124"><br>
voltile 키워드를 사용하면 Main Memory에 있는 변수를 CPU 캐시메모리에 캐시를 하지 않고 바로 Main Memory에서 가져오게 됩니다.

## 팩토리 패턴
팩토리패턴이란 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴입니다.
상위 클래스에서는 객체 생성방식에 대해 알 필요가 없어져 유연성을 갖게 되며 객체 생성 로직은 하위 클래스에서만 관리 되기 때문에 유지 보수성이 증가됩니다.

## 이터레이턴 패턴
이터레이터패턴은 이터레이터(iterator)를 사용하여 컨테이너의 요소들에 접근하는 디자인 패턴입니다. 각기 다른 자료구조들을 똑같은 인터페이스로 순회를 쉽게 할 수 있다는 장점이 있습니다. 컨테이너란 동일한 요소들을 담아놓는 집합을 말합니다. 배열, 맵등이 있습니다.

## 의존성주입과 의존관계역전원칙
의존성주입(Dependency Injection)이란 메인 모듈(main module)이 '직접' 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 의존성 주입자(dependency injector)가 이 부분을 가로채 메인 모듈이 '간접'적으로 의존성을 주입하는 방식입니다.<br>
<img width=400 alt="image" src="/images/의존성주입.png"><br>
이를 통해 메인 모듈과 하위모듈간의 의존성을 조금 더 느슨하게 만들 수 있으며 모듈을 **쉽게 교체 가능한 구조**로 만듭니다.<br>
### 의존한다. 라는 의미
A가 B에 의존한다. = B가 변하면 A에 영향을 미치는 관계 = A -> B 를 의미한다.
### 의존관계역전원칙
의존성 주입을 할 때는 의존관계역전원칙(Dependency Inversion Principle)이 적용됩니다.  이는 2가지의 규칙을 지키는 상태를 말합니다.
- 상위 모듈은 하위 모듈에 의존해서는 안된다. 둘다 추상화에 의존해야 한다.
- 추상화는 세부사항에 의존해서는 안된다. 세부사항은 추상화에 따라 달라져야 한다.
### 의존성 주입의 장점
1. 외부에서 모듈을 생서하여 dev.add(new BackendDeveloper()) 이런식으로 집어 넣는 구조가 되기 때문에 모듈들을 쉽게 교체할 수 있는 구조가 됩니다.
2. 단위 테스팅과 마이그레이션이 쉬워집니다.
3. 애플리케이션 의존성 방향이 좀 더 일관되어 코드를 추론하기가 쉬워집니다.
### 의존성 주입의 단점
1. 결국에는 모듈이 더 생기게 되므로 복잡도가 증가합니다.
2. 종속성 주입자체가 컴파일을 할 때가 아닌 런타임 때 일어나기 때문에 컴파일을 할 때 종속성 주입에 관한 에러를 잡기가 어려워질 수 있습니다.


## 전략패턴
전략패턴이란 전략이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트(행위, 상황) 안에서 바꿔주면서 상호 교체가 가능하게 만드는 디자인 패턴입니다. 로그인을 할 때 Local Strategy를 할 수도 있고 네이버, 카카오 구글 로그인을 할 수 있는데 이것을 전략 패턴으로 구현할 수 있습니다.
전략 패턴이 들어가 있는 라이브러리가 있는데 js에서는 `passportjs.org`가 있습니다.


## 옵저버패턴
옵저번패턴이란 주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴입니다.<br>
트위터의 메인 로직, 그리고 MVC패턴에도 적용되었습니다. MVC패턴에서는 모델이 변경되면 뷰에게 알려주어 뷰가 변경되는 것을 알 수 있게 합니다. 


## 프록시 패턴
프록시패턴이란 객체가 어떤 대상 객체에 접근하기 전, 그 접근에 대한 흐름을 가로채서 해당 접근을 필터링하거나 수정하는 등의 역할을 하는 계층이 있는 디자인패턴입니다.

## MVC MVP MVVM패턴
### MVC 패턴
MVC패턴은 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴입니다.<br>
<img width="476" alt="image" src="/images/MVC.png"><br>
#### 모델
모델(model)은 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻합니다.
뷰에서 데이터를 생성하거나 수정할 때 컨트롤러를 통해 모델이 생성 또는 업데이트 됩니다.
예를 들어 사용자가 네모박스에 글자를 적는다고 해보죠. 이 때 모델은 네모박스의 크기정보, 글자내용, 글자의 위치, 글자의 포맷정보 등이 됩니다.
#### 뷰
뷰(view)는 inputbox, checkbox, textarea 등 사용자 인터페이스 요소를 나타내며 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻합니다. 모델이 가지고 있는 정보를 따로 저장하지 않아야 하며 변경이 일어나면 컨트롤러에 이를 전달해야 합니다.
#### 컨트롤러
컨트롤러(controller)는 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당합니다. 또한, 모델과 뷰의 생명주기도 관리하며, 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성 요소에 해당 내용에 대해 알려줍니다.
#### MVC패턴의 장점
1. 애플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있습니다.
2. 재사용성과 확장성이 용이하다는 장점이 있습니다.
#### MVC패턴의 단점
애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해지는 단점이 있습니다.

MVC 패턴을 반영한 대표적인 프레임워크로 Spring WEB MVC가 있습니다.

### MVP 패턴
C가 P(프레젠터, presenter)로 교체된 패턴. V와 P는 1:1 관계이므로 MVC보다 더 강한 결합을 지닌 디자인 패턴입니다.<br>
<img width="476" alt="image" src="/images/MVP.png"><br>

### MVVM 패턴
MVC의 C가 VM(뷰모델, view model)로 바뀐 패턴. VM은 뷰를 추상화한 계층이며 VM : V = 1 : N 이라는 관계를 갖습니다.
<img width="476" alt="image" src="/images/MVVM.png"><br>
VM은 커맨드와 데이터 바인딩을 가집니다.
- 커맨드 : 여러 요소에 대한 처리를 하나의 액션으로 처리할 수 있는 기법
- 데이터바인딩 : 화면에 보이는 데이터와 브라우저 상의 메모리 데이터를 일치시키는 방법.
MVVM 패턴을 가진 대표적인 프레임워크로는 뷰(Vue.js)가 있습니다.

차이 정리

| 특징 | MVC 패턴         | MVP 패턴       | MVVM 패턴       |
|----|----------------|--------------|---------------|
| 관계 | 컨트롤러와 뷰는 1 : n | 프레젠터와 뷰는 1:1 | 뷰모델과 뷰는 1 : n |
| 참조 | 뷰는 컨트롤러를 참조 x | 뷰는 프레젠터를 참조 o | 뷰는 뷰 모델을 참조 o |
