# PATTERNS 

# singleton-code

클래스 이름 뒤에 01, 02, 03 이순서로 확인한다.
싱글톤을 사용하는 방법들중에 SingletonInstanceHolder04 클래스의 방법과 Enum을 사용하는 방법을 가장 많이 사용한다. 이펙티브 자바를 쓴 조슈아 블로크가 추천한 방법이기도 하다.

## 정적 멤버
정적(statiac) 멤버나 블록은 런타임이 아니라 최초에 JVM이 클래스 로딩 때 모든 클래스들을 로드할 때 미리 인스턴스를 생성하는데 이를 이용한 방법입니다.
클래스 로딩과 동시에 싱글톤 인스턴스를 만듭니다. 그렇기 때문에 모듈들이 싱글톤 인스턴스를 요청할 때 그냥 만들어진 인스턴스를 반환하면 되는 것이죠.

이는 불필요한 자원낭비라는 문제점이 있습니다. 싱글톤 인스턴스가 필요없는 경우도 무조건 싱글톤 클래스를 호출해 인스턴스를 만들어야 하기 때문입니다. 이문제는 정적 블록 문제점이기도 합니다.

## volatile
SingletonDoubleLock에 instance라는 변수에 volatile 키워드를 건 것을 볼 수 있는데요.
여기서 instance라는 변수에 volatile 키워드를 건 것을 볼 수 있는데요.
왜 그랬을까요?
메모리 구조는 다음과 같습니다. 메인 메모리 위에 CPU 캐시메모리라고 불리는 L3, L3, L1 캐시가 있습니다. (L4도 드물긴 하지만 L4까지 CPU 캐시 메모리라고 부릅니다.)<br>
<img width="348" alt="image" src="https://github.com/SeongjinOliver/singleton-code/assets/55625864/5e22838b-6445-4e3f-ab93-13b0d97b490c"><br>
JAVA에서는 스레드 2개가 열리면 변수를 메인 메모리(RAM)으로부터 가져오는 것이 아니라 캐시메모리에서 각각의 캐시메모리를 기반으로 가져오게 됩니다.
<img width="476" alt="image" src="https://github.com/SeongjinOliver/singleton-code/assets/55625864/826384fb-4b52-4ecb-bb71-4c93956c0124"><br>
voltile 키워드를 사용하면 Main Memory에 있는 변수를 CPU 캐시메모리에 캐시를 하지 않고 바로 Main Memory에서 가져오게 됩니다.

## 팩토리 패턴
팩토리패턴이란 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴입니다.
상위 클래스에서는 객체 생성방식에 대해 알 필요가 없어져 유연성을 갖게 되며 객체 생성 로직은 하위 클래스에서만 관리 되기 때문에 유지 보수성이 증가됩니다.

## 이터레이턴 패턴
이터레이터패턴은 이터레이터(iterator)를 사용하여 컨테이너의 요소들에 접근하는 디자인 패턴입니다. 각기 다른 자료구조들을 똑같은 인터페이스로 순회를 쉽게 할 수 있다는 장점이 있습니다. 컨테이너란 동일한 요소들을 담아놓는 집합을 말합니다. 배열, 맵등이 있습니다.

## 의존성주입과 의존관계역전원칙
의존성주입(Dependency Injection)이란 메인 모듈(main module)이 '직접' 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 의존성 주입자(dependency injector)가 이 부분을 가로채 메인 모듈이 '간접'적으로 의존성을 주입하는 방식입니다.<br>
<img width=400 alt="image" src="/images/의존성주입.png"><br>
이를 통해 메인 모듈과 하위모듈간의 의존성을 조금 더 느슨하게 만들 수 있으며 모듈을 **쉽게 교체 가능한 구조**로 만듭니다.<br>
### 의존한다. 라는 의미
A가 B에 의존한다. = B가 변하면 A에 영향을 미치는 관계 = A -> B 를 의미한다.
### 의존관계역전원칙
의존성 주입을 할 때는 의존관계역전원칙(Dependency Inversion Principle)이 적용됩니다.  이는 2가지의 규칙을 지키는 상태를 말합니다.
- 상위 모듈은 하위 모듈에 의존해서는 안된다. 둘다 추상화에 의존해야 한다.
- 추상화는 세부사항에 의존해서는 안된다. 세부사항은 추상화에 따라 달라져야 한다.
### 의존성 주입의 장점
1. 외부에서 모듈을 생서하여 dev.add(new BackendDeveloper()) 이런식으로 집어 넣는 구조가 되기 때문에 모듈들을 쉽게 교체할 수 있는 구조가 됩니다.
2. 단위 테스팅과 마이그레이션이 쉬워집니다.
3. 애플리케이션 의존성 방향이 좀 더 일관되어 코드를 추론하기가 쉬워집니다.
### 의존성 주입의 단점
1. 결국에는 모듈이 더 생기게 되므로 복잡도가 증가합니다.
2. 종속성 주입자체가 컴파일을 할 때가 아닌 런타임 때 일어나기 때문에 컴파일을 할 때 종속성 주입에 관한 에러를 잡기가 어려워질 수 있습니다.


## 전략패턴
전략패턴이란 전략이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트(행위, 상황) 안에서 바꿔주면서 상호 교체가 가능하게 만드는 디자인 패턴입니다. 로그인을 할 때 Local Strategy를 할 수도 있고 네이버, 카카오 구글 로그인을 할 수 있는데 이것을 전략 패턴으로 구현할 수 있습니다.
전략 패턴이 들어가 있는 라이브러리가 있는데 js에서는 `passportjs.org`가 있습니다.


## 옵저버패턴
옵저번패턴이란 주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴입니다.<br>
트위터의 메인 로직, 그리고 MVC패턴에도 적용되었습니다. MVC패턴에서는 모델이 변경되면 뷰에게 알려주어 뷰가 변경되는 것을 알 수 있게 합니다. 


## 프록시 패턴
프록시패턴이란 객체가 어떤 대상 객체에 접근하기 전, 그 접근에 대한 흐름을 가로채서 해당 접근을 필터링하거나 수정하는 등의 역할을 하는 계층이 있는 디자인패턴입니다.

## MVC MVP MVVM패턴
### MVC 패턴
MVC패턴은 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴입니다.<br>
<img width="476" alt="image" src="/images/MVC.png"><br>
#### 모델
모델(model)은 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻합니다.
뷰에서 데이터를 생성하거나 수정할 때 컨트롤러를 통해 모델이 생성 또는 업데이트 됩니다.
예를 들어 사용자가 네모박스에 글자를 적는다고 해보죠. 이 때 모델은 네모박스의 크기정보, 글자내용, 글자의 위치, 글자의 포맷정보 등이 됩니다.
#### 뷰
뷰(view)는 inputbox, checkbox, textarea 등 사용자 인터페이스 요소를 나타내며 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻합니다. 모델이 가지고 있는 정보를 따로 저장하지 않아야 하며 변경이 일어나면 컨트롤러에 이를 전달해야 합니다.
#### 컨트롤러
컨트롤러(controller)는 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당합니다. 또한, 모델과 뷰의 생명주기도 관리하며, 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성 요소에 해당 내용에 대해 알려줍니다.
#### MVC패턴의 장점
1. 애플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있습니다.
2. 재사용성과 확장성이 용이하다는 장점이 있습니다.
#### MVC패턴의 단점
애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해지는 단점이 있습니다.

MVC 패턴을 반영한 대표적인 프레임워크로 Spring WEB MVC가 있습니다.

### MVP 패턴
C가 P(프레젠터, presenter)로 교체된 패턴. V와 P는 1:1 관계이므로 MVC보다 더 강한 결합을 지닌 디자인 패턴입니다.<br>
<img width="476" alt="image" src="/images/MVP.png"><br>

### MVVM 패턴
MVC의 C가 VM(뷰모델, view model)로 바뀐 패턴. VM은 뷰를 추상화한 계층이며 VM : V = 1 : N 이라는 관계를 갖습니다.
<img width="476" alt="image" src="/images/MVVM.png"><br>
VM은 커맨드와 데이터 바인딩을 가집니다.
- 커맨드 : 여러 요소에 대한 처리를 하나의 액션으로 처리할 수 있는 기법
- 데이터바인딩 : 화면에 보이는 데이터와 브라우저 상의 메모리 데이터를 일치시키는 방법.
MVVM 패턴을 가진 대표적인 프레임워크로는 뷰(Vue.js)가 있습니다.

차이 정리

| 특징 | MVC 패턴         | MVP 패턴       | MVVM 패턴       |
|----|----------------|--------------|---------------|
| 관계 | 컨트롤러와 뷰는 1 : n | 프레젠터와 뷰는 1:1 | 뷰모델과 뷰는 1 : n |
| 참조 | 뷰는 컨트롤러를 참조 x | 뷰는 프레젠터를 참조 o | 뷰는 뷰 모델을 참조 o |

## Spring의 MVC패턴 적용사례
Spring은 자바기반으로 애플리케이션 개발을 할 때 많은 기능들을 제공하는 프레임워크입니다. 다음과 같은 아키텍처를 가지죠.
<img width="476" alt="image" src="/images/SpringFrameWorkRuntime.png"><br>
이 중에서 MVC 패턴이 적용된 Web 모듈의 Spring Web MVC를 살펴보겠습니다.
### 디스패처 서블릿의 요청 처리과정
<img width="476" alt="image" src="/images/DispatcherServlet.png"><br>

## Flux 패턴
flux패턴은 **단방향**으로 데이터 흐름을 관리하는 디자인패턴입니다.
페이스북에서 "읽은 표시(mark seen)"에 대한 기능장애를 겪었습니다. 어떤 페이지에서는 메시지를 읽었는데 다른 페이지에서는 메시지가 안 읽었다과 뜨는 것이죠.
### Flux 패턴의 구조
<img width="476" alt="image" src="/images/FluxArchitecture.png"><br>
#### Action
사용자의 이벤트를 담당합니다. 마우스 ㅡㅋㄹ릭이나, 글을 쓴다던가 등을 의미하며 해당 이벤트에 관한 객체를 만들어내 dispatcher에게 전달합니다.
#### Dispatcher
Dispatcher는 들어오는 Action 객체 정보를 기반 어떠한 "행위"를 할 것인가를 결정합니다. 보통 action 객체의 type를 기반으로 미리 만들어 놓은 로직을 수행하고 이를 Store에 전달합니다.
#### Store
스토어는 애플리케이션 상태를 관리하고 저장하는 계층입니다. 도메인의 상태, 사용자의 인터페이스 등의 상태를 모두 저장합니다.
#### View
데이터를 기반으로 표출이 되는 사용자인터페이스입니다.

## 전략패턴과 DI의 차이?
의존성주입이나 전략패턴 모두 무언가를 쉽게 교체하기 위한 디자인패턴이라는 공통점이 있습니다. 그러나 다음과 같은 차이가 있습니다.
전략패턴: 어떠한 동일한 행동 계약을 기반으로 다양한 구현이 명시되어 있는 인터페이스를 만드는 것을 포함합니다.
의존성주입: 단지 일부 동작을 구현하고 의존성을 주입하기만 하는 패턴입니다.

## 컨텍스트
컨텍스트는 2가지 뜻으로 씁니다.
1. 어떤 종류의 상태, 환경을 캡슐화한 것을 말함.
2. 작업이 중단 되고 나중에 같은 지점에서 계속 될 수 있도록 저장하는 최소 데이터 집합. (컨텍스트스위칭)

context와 contextual information으로 나눠짐
1. 병원에 가면 "이름"과 주민등록번호 앞자리를 말해야죠?
자 여기서 "병원에 방문"하는 context에서 여러분의 이름은 contextual information
2. HTTP 요청을 하는 context에서 HTTP Header는 contextual information이라고 할 수 있습니다.

이러한 이론을 기반으로 한 다양한 모듈 또는 API로는 react.js에서는 전역적으로 “상태”값을 넘길 수 있는 context API가 있습니다.
<img width="476" alt="image" src="/images/ContextAPI.png"><br>
React에서 context API를 통해 전역적으로 static contextType을 통해 상태관리를 하는 모습입니다.